// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17; // ✅ works 0.8.17‒0.8.31, with or without --via-ir

/\*\*

- @title SimpleTutoringPlatform
- @notice Basic tutoring platform with session management and payments.
- @dev Refactored to avoid the two classic compiler errors:
-      1. UnimplementedFeatureError on nested dynamic arrays (string[] calldata ➔ storage).
-      2. Stack-too-deep inside large functions.

  */
  contract SimpleTutoringPlatform {
  /*─────────────────── DATA STRUCTURES ───────────────────\*/

      struct TutorProfile {
          bool isRegistered;
          bool isActive;
          string name;
          string[] subjects;
          uint256 hourlyRate;       // wei per hour
          uint256 totalRating;      // sum of stars
          uint256 ratingCount;      // number of ratings
          uint256 completedSessions;
          uint256 totalEarnings;    // wei earned (after fees)
          mapping(string => bool) subjectCertified;
      }

      struct StudentProfile {
          bool isRegistered;
          string name;
          uint256 totalSpent;
          uint256 sessionsCompleted;
          uint256[] sessionHistory;
      }

      struct Session {
          uint256 id;
          address student;
          address tutor;
          string  subject;
          uint256 duration;         // minutes
          uint256 cost;             // wei
          uint256 startTime;        // epoch
          uint256 endTime;          // epoch
          SessionStatus status;
          uint256 escrow;           // wei locked
          uint256 studentRating;    // 1-5
          uint256 tutorRating;      // 1-5
          string  feedback;
      }

      enum SessionStatus { Pending, Confirmed, InProgress, Completed, Cancelled, Disputed }

      /*───────────────────  STATE  ───────────────────*/

      mapping(address => TutorProfile) private tutors;
      mapping(address => StudentProfile) private students;
      mapping(uint256 => Session)        public  sessions;

      uint256 public sessionCounter;
      uint256 public platformFeeBps = 500;               // 5% (basis points)
      uint256 public constant MIN_DURATION = 30 minutes;
      uint256 public constant MAX_DURATION = 8 hours;
      uint256 public constant DISPUTE_TIMEOUT = 7 days;

      address public immutable owner;
      address public feeRecipient;
      address public disputeResolver;
      bool    public paused;

      /*───────────────────  MODIFIERS  ───────────────────*/

      modifier onlyOwner()                 { require(msg.sender == owner, "Not owner"); _; }
      modifier whenNotPaused()             { require(!paused, "Paused"); _; }
      modifier onlyTutor()                 { require(_isActiveTutor(msg.sender), "Tutor inactive"); _; }
      modifier onlyStudent()               { require(students[msg.sender].isRegistered, "Not student"); _; }
      modifier sessionExists(uint256 id)   { require(id != 0 && id <= sessionCounter, "No session"); _; }
      modifier onlyParticipant(uint256 id) {
          Session storage s = sessions[id];
          require(msg.sender == s.student || msg.sender == s.tutor, "Not participant");
          _;
      }
      modifier noReentrancy() {
          require(!_locked, "Reentrancy");
          _locked = true;
          _;
          _locked = false;
      }
      bool private _locked;

      /*───────────────────  EVENTS  ───────────────────*/

      event TutorRegistered(address indexed tutor, string name);
      event StudentRegistered(address indexed student, string name);
      event SessionBooked(uint256 indexed id, address indexed student, address indexed tutor);
      event SessionConfirmed(uint256 indexed id);
      event SessionStarted(uint256 indexed id);
      event SessionCompleted(uint256 indexed id, uint256 studentRating, uint256 tutorRating);
      event SessionCancelled(uint256 indexed id, string reason);
      event PaymentReleased(uint256 indexed id, address indexed tutor, uint256 amount);
      event TutorRatingUpdated(address indexed tutor, uint256 avgRating, uint256 ratingCount);

      /*───────────────────  CONSTRUCTOR  ───────────────────*/

      constructor(address _feeRecipient) {
          require(_feeRecipient != address(0), "Zero address");
          owner          = msg.sender;
          feeRecipient   = _feeRecipient;
          disputeResolver = msg.sender;
      }

      /*───────────────────  REGISTRATION  ───────────────────*/

      function registerTutor(
          string calldata _name,
          string[] calldata _subjects,
          uint256 _hourlyRate
      ) external whenNotPaused {
          require(!tutors[msg.sender].isRegistered, "Already tutor");
          require(_hourlyRate != 0,                  "Rate 0");
          require(_subjects.length != 0,             "No subjects");
          require(bytes(_name).length != 0,          "Empty name");

          TutorProfile storage t = tutors[msg.sender];
          t.isRegistered = true;
          t.isActive     = true;
          t.name         = _name;
          t.hourlyRate   = _hourlyRate;

          // element-by-element copy avoids the nested-array error on legacy backend
          for (uint256 i; i < _subjects.length; ++i) {
              require(bytes(_subjects[i]).length != 0, "Empty subject");
              t.subjects.push(_subjects[i]);
              t.subjectCertified[_subjects[i]] = true;
          }
          emit TutorRegistered(msg.sender, _name);
      }

      function registerStudent(string calldata _name) external whenNotPaused {
          require(!students[msg.sender].isRegistered, "Already student");
          require(bytes(_name).length != 0, "Empty name");
          students[msg.sender].isRegistered = true;
          students[msg.sender].name = _name;
          emit StudentRegistered(msg.sender, _name);
      }

      /*───────────────────  SESSION FLOW  ───────────────────*/

      function bookSession(
          address  _tutor,
          string   calldata _subject,
          uint256  _minutes,
          uint256  _start
      ) external payable onlyStudent whenNotPaused noReentrancy {
          require(_tutor != address(0), "Zero address");
          require(_tutor != msg.sender, "Cannot tutor yourself");
          require(bytes(_subject).length != 0, "Empty subject");

          TutorProfile storage t = tutors[_tutor];
          require(_isActiveTutor(_tutor),                  "Tutor inactive");
          require(t.subjectCertified[_subject],            "Tutor uncertified");
          require(_minutes >= MIN_DURATION / 1 minutes && _minutes <= MAX_DURATION / 1 minutes,
                  "Bad duration");
          require(_start > block.timestamp,                "Start past");

          uint256 cost = _calcCost(t.hourlyRate, _minutes);
          require(msg.value >= cost,                       "Underpaid");

          // create session
          uint256 id = ++sessionCounter;
          sessions[id] = Session({
              id: id,
              student: msg.sender,
              tutor:   _tutor,
              subject: _subject,
              duration:_minutes,
              cost:    cost,
              startTime: _start,
              endTime:   _start + _minutes * 1 minutes,
              status:  SessionStatus.Pending,
              escrow:  cost,
              studentRating: 0,
              tutorRating:   0,
              feedback: ""
          });

          students[msg.sender].sessionHistory.push(id);

          // refund any excess
          if (msg.value > cost) {
              payable(msg.sender).transfer(msg.value - cost);
          }

          emit SessionBooked(id, msg.sender, _tutor);
      }

      function confirmSession(uint256 id)
          external onlyTutor sessionExists(id) whenNotPaused
      {
          Session storage s = sessions[id];
          require(msg.sender == s.tutor,             "Not tutor");
          require(s.status == SessionStatus.Pending, "Not pending");
          s.status = SessionStatus.Confirmed;
          emit SessionConfirmed(id);
      }

      function startSession(uint256 id)
          external onlyParticipant(id) sessionExists(id) whenNotPaused
      {
          Session storage s = sessions[id];
          require(s.status == SessionStatus.Confirmed, "Not confirmed");
          require(block.timestamp >= s.startTime,      "Too early");
          require(block.timestamp <= s.startTime + 30 minutes, "30-min window passed");
          s.status = SessionStatus.InProgress;
          emit SessionStarted(id);
      }

      function completeSession(
          uint256 id,
          uint256 rating,
          string calldata feedback
      ) external onlyParticipant(id) sessionExists(id) whenNotPaused {
          require(rating >= 1 && rating <= 5,                "Bad rating");
          Session storage s = sessions[id];
          require(s.status == SessionStatus.InProgress,      "Not in progress");

          if (msg.sender == s.student) {
              require(s.studentRating == 0, "Student already rated");
              s.studentRating = rating;
          } else {
              require(s.tutorRating == 0,   "Tutor already rated");
              s.tutorRating = rating;
          }

          // Update feedback only if provided
          if (bytes(feedback).length > 0) {
              s.feedback = feedback;
          }

          // Finalize when both parties have rated
          if (s.studentRating != 0 && s.tutorRating != 0) {
              _finalize(id);
          }

          emit SessionCompleted(id, s.studentRating, s.tutorRating);
      }

      function cancelSession(uint256 id, string calldata reason)
          external onlyParticipant(id) sessionExists(id) whenNotPaused noReentrancy
      {
          Session storage s = sessions[id];
          require(s.status == SessionStatus.Pending || s.status == SessionStatus.Confirmed,
                  "Cannot cancel");
          s.status = SessionStatus.Cancelled;

          uint256 refund = s.escrow;
          s.escrow = 0;

          // Apply late cancellation fee if student cancels within 1 hour of start
          if (msg.sender == s.student && block.timestamp > s.startTime - 1 hours) {
              uint256 fee = refund * 20 / 100;           // 20% late-cancel fee
              refund -= fee;
              if (fee > 0) {
                  payable(feeRecipient).transfer(fee);
              }
          }

          if (refund > 0) {
              payable(s.student).transfer(refund);
          }

          emit SessionCancelled(id, reason);
      }

      /*───────────────────  INTERNAL HELPERS  ───────────────────*/

      function _finalize(uint256 id) internal {
          Session storage s = sessions[id];
          s.status = SessionStatus.Completed;

          // update tutor stats
          TutorProfile storage t = tutors[s.tutor];
          t.totalRating += s.studentRating;
          t.ratingCount += 1;
          t.completedSessions += 1;

          // update student stats
          StudentProfile storage stu = students[s.student];
          stu.sessionsCompleted += 1;
          stu.totalSpent += s.cost;

          _payout(id);

          emit TutorRatingUpdated(s.tutor, t.totalRating / t.ratingCount, t.ratingCount);
      }

      function _payout(uint256 id) internal {
          Session storage s = sessions[id];
          uint256 amount = s.escrow;
          require(amount != 0, "No escrow");

          uint256 fee = amount * platformFeeBps / 10_000;
          uint256 net = amount - fee;
          s.escrow = 0;

          tutors[s.tutor].totalEarnings += net;

          if (net > 0) {
              payable(s.tutor).transfer(net);
          }
          if (fee > 0) {
              payable(feeRecipient).transfer(fee);
          }

          emit PaymentReleased(id, s.tutor, net);
      }

      function _isActiveTutor(address a) internal view returns (bool) {
          return tutors[a].isRegistered && tutors[a].isActive;
      }

      function _calcCost(uint256 ratePerHour, uint256 minutes_)
          internal pure returns (uint256)
      {
          return ratePerHour * minutes_ / 60;
      }

      /*───────────────────  VIEWS  ───────────────────*/

      function getTutorInfo(address tutor) external view returns (
          bool isRegistered,
          bool isActive,
          string memory name,
          uint256 hourlyRate,
          uint256 avgRating,
          uint256 ratingCount,
          uint256 completedSessions
      ) {
          TutorProfile storage t = tutors[tutor];
          uint256 avg = t.ratingCount == 0 ? 0 : t.totalRating / t.ratingCount;
          return (t.isRegistered, t.isActive, t.name, t.hourlyRate, avg, t.ratingCount, t.completedSessions);
      }

      function getStudentInfo(address student) external view returns (
          bool isRegistered,
          string memory name,
          uint256 totalSpent,
          uint256 sessionsCompleted,
          uint256 sessionCount
      ) {
          StudentProfile storage s = students[student];
          return (s.isRegistered, s.name, s.totalSpent, s.sessionsCompleted, s.sessionHistory.length);
      }

      function tutorRating(address tutor) external view returns (uint256) {
          TutorProfile storage t = tutors[tutor];
          return t.ratingCount == 0 ? 0 : t.totalRating / t.ratingCount;
      }

      function tutorSubjects(address tutor) external view returns (string[] memory) {
          return tutors[tutor].subjects;
      }

      function studentHistory(address student) external view returns (uint256[] memory) {
          return students[student].sessionHistory;
      }

      function sessionBrief(uint256 id) external view returns (
          address student,
          address tutor,
          SessionStatus status,
          uint256 cost
      ) {
          Session storage s = sessions[id];
          return (s.student, s.tutor, s.status, s.cost);
      }

      function getSessionDetails(uint256 id) external view sessionExists(id) returns (
          uint256 sessionId,
          address student,
          address tutor,
          string memory subject,
          uint256 duration,
          uint256 cost,
          uint256 startTime,
          uint256 endTime,
          SessionStatus status,
          uint256 studentRating,
          uint256 tutorRating,
          string memory feedback
      ) {
          Session storage s = sessions[id];
          return (s.id, s.student, s.tutor, s.subject, s.duration, s.cost,
                  s.startTime, s.endTime, s.status, s.studentRating, s.tutorRating, s.feedback);
      }

      /*───────────────────  ADMIN  ───────────────────*/

      function setPlatformFee(uint256 bps) external onlyOwner {
          require(bps <= 1000, "Max 10%");
          platformFeeBps = bps;
      }

      function setFeeRecipient(address _feeRecipient) external onlyOwner {
          require(_feeRecipient != address(0), "Zero address");
          feeRecipient = _feeRecipient;
      }

      function setDisputeResolver(address r) external onlyOwner {
          require(r != address(0), "Zero address");
          disputeResolver = r;
      }

      function setTutorActive(address tutor, bool active) external onlyOwner {
          require(tutors[tutor].isRegistered, "Not registered");
          tutors[tutor].isActive = active;
      }

      function pause()     external onlyOwner { paused = true;  }
      function unpause()   external onlyOwner { paused = false; }

      function emergencyWithdraw(uint256 id)
          external onlyOwner sessionExists(id) noReentrancy
      {
          Session storage s = sessions[id];
          require(s.escrow != 0,                         "No funds");
          require(block.timestamp > s.endTime + DISPUTE_TIMEOUT,
                  "Dispute window open");
          uint256 amt = s.escrow;
          s.escrow = 0;
          payable(feeRecipient).transfer(amt);
      }

      /*───────────────────  FALLBACK  ───────────────────*/

      receive() external payable { revert("Direct ether denied"); }

  }
